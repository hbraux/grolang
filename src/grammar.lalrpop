use std::str::FromStr;
use crate::{Expr, Opcode, Type, TRUE, FALSE, NULL};

// see https://lalrpop.github.io/lalrpop/tutorial/index.html
// Ignore plugin warnings on <> !

grammar;

pub Statement: Box<Expr>  = {
    Declaration,
    Assignment,
    Expr
};


Declaration: Box<Expr> = {
    "var " <id:Id> <t:(TypeSpec?)> "=" <e:Expr>  => Box::new(Expr::Declare(<>))
}

Assignment: Box<Expr> = {
     <id:Id> "=" <e:Expr>  => Box::new(Expr::Assign(<>))
}


Expr: Box<Expr> = {
    Expr ExprOp Factor => Box::new(Expr::BinaryOp(<>)),
    MethodCall,
    Factor,
    Literal,
};


MethodCall : Box<Expr> = {
  <e:Expr> "." <id:Id> "(" <l:Comma<Expr>> ")" => Box::new(Expr::Call(<>))
}

ExprOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
    "==" => Opcode::Eq,
    "!=" => Opcode::Neq,
    ">=" => Opcode::Ge,
    ">" => Opcode::Gt,
    "<=" => Opcode::Le,
    "<" => Opcode::Lt,
};

Factor: Box<Expr> = {
    Factor FactorOp Term => Box::new(Expr::BinaryOp(<>)),
    Term,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
    "%" => Opcode::Mod,
};

Literal: Box<Expr> = {
    "true"  => Box::new(TRUE),
    "false" => Box::new(FALSE),
    "null"  => Box::new(NULL),
}

Term: Box<Expr> = {
    Int     => Box::new(Expr::Int(<>)),
    Float   => Box::new(Expr::Float(<>)),
    Str     => Box::new(Expr::Str(<>)),
    Id      => Box::new(Expr::Id(<>)),
    "(" <Expr> ")"
};

Int: i64 = <s:r"-?\d+(_\d+)*"> => i64::from_str(&*s.replace("_","")).unwrap();

Float: f64 = <s:r"-?\d+\.\d*(e-?\d+)?"> => f64::from_str(s).unwrap();

Str: String = <l:r#""[a-zA-Z0-9 ]*""#> => l[1..l.len()-1].into();

TypeSpec: Type = <s:r": *[A-Z][A-Za-z]*(<[A-Z][A-Za-z]*>)?"> => Type::new(s.replace(":","").trim());

Id: String = <s:r"[A-Za-z][A-Za-z0-9]*"> => s.to_string();


Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => { v.push(e); v }
    }
};
