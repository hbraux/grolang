use std::str::FromStr;
use crate::{Expr, Opcode, TRUE, FALSE, NULL};

// see https://lalrpop.github.io/lalrpop/tutorial/index.html

grammar;

pub Statement: Box<Expr>  = {
    Declaration,
    MethodCall,
    Expr
};

Declaration: Box<Expr> = {
    "var" <id:Id> "=" <t:(TypeSpec?)> <e:Expr>  => Box::new(Expr::Declare(<>))
}


MethodCall : Box<Expr> = {
  <e:Expr> "." <id:Id> "(" <l:Comma<Expr>> ")" => Box::new(Expr::Call(<>))
}

Expr: Box<Expr> = {
    Expr ExprOp Factor => Box::new(Expr::BinaryOp(<>)),
    Factor,
    Literal
};

ExprOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
    "==" => Opcode::Eq,
    "!=" => Opcode::Neq,
    ">=" => Opcode::Ge,
    ">" => Opcode::Gt,
    "<=" => Opcode::Le,
    "<" => Opcode::Lt,
};

Factor: Box<Expr> = {
    Factor FactorOp Term => Box::new(Expr::BinaryOp(<>)),
    Term,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
    "%" => Opcode::Mod,
};

Literal: Box<Expr> = {
    "true"  => Box::new(TRUE),
    "false" => Box::new(FALSE),
    "null"  => Box::new(NULL),
}

Term: Box<Expr> = {
    Int     => Box::new(Expr::Int(<>)),
    Float   => Box::new(Expr::Float(<>)),
    Str     => Box::new(Expr::Str(<>)),
    Id      => Box::new(Expr::Id(<>)),
    "(" <Expr> ")"
};

Int: i64 = <s:r"-?\d+"> => i64::from_str(s).unwrap();

Float: f64 = <s:r"-?\d+\.\d*"> => f64::from_str(s).unwrap();

Str: String = <l:r#""[a-z ]*""#> => l[1..l.len()-1].into();

TypeSpec: String = <s:r":[A-Z][A-Za-z]*(<[A-Z][A-Za-z]*>)?"> => s.to_string();

Id: String = <s:r"[A-Za-z][A-Za-z0-9]*"> => s.to_string();


Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => { v.push(e); v }
    }
};
